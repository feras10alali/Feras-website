import "./chunk-SA3VOP2B.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  check_outros,
  children,
  claim_element,
  claim_space,
  claim_text,
  compute_rest_props,
  create_slot,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  noop,
  prop_dev,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  space,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-3XCKNI7N.js";
import "./chunk-EKIRE5YT.js";
import "./chunk-V6TY7KAL.js";

// node_modules/@auth/sveltekit/dist/components/SignIn.svelte
import { enhance } from "$app/forms";
var file = "node_modules\\@auth\\sveltekit\\dist\\components\\SignIn.svelte";
var get_submitButton_slot_changes = (dirty) => ({});
var get_submitButton_slot_context = (ctx) => ({});
var get_email_slot_changes = (dirty) => ({});
var get_email_slot_context = (ctx) => ({});
var get_credentials_slot_changes = (dirty) => ({});
var get_credentials_slot_context = (ctx) => ({});
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i][0];
  child_ctx[12] = list[i][1];
  return child_ctx;
}
function create_if_block_4(ctx) {
  let input;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, name: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "hidden");
      attr_dev(input, "name", "callbackUrl");
      input.value = /*callbackUrl*/
      ctx[3];
      add_location(input, file, 20, 4, 809);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(20:2) {#if callbackUrl}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let input;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, name: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "hidden");
      attr_dev(input, "name", "redirect");
      input.value = /*redirect*/
      ctx[4];
      add_location(input, file, 23, 4, 901);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(23:2) {#if redirect}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like_dev(Object.entries(
    /*authorizationParamsInputs*/
    ctx[5]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*Object, authorizationParamsInputs*/
      32) {
        each_value = ensure_array_like_dev(Object.entries(
          /*authorizationParamsInputs*/
          ctx2[5]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(26:2) {#if authorizationParamsInputs}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let input;
  let input_name_value;
  let input_value_value;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, name: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "hidden");
      attr_dev(input, "name", input_name_value = `authorizationParams-${/*key*/
      ctx[11]}`);
      input.value = input_value_value = /*value*/
      ctx[12];
      add_location(input, file, 27, 6, 1076);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(27:4) {#each Object.entries(authorizationParamsInputs) as [key, value]}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let current;
  const credentials_slot_template = (
    /*#slots*/
    ctx[10].credentials
  );
  const credentials_slot = create_slot(
    credentials_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_credentials_slot_context
  );
  const block = {
    c: function create() {
      if (credentials_slot) credentials_slot.c();
    },
    l: function claim(nodes) {
      if (credentials_slot) credentials_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (credentials_slot) {
        credentials_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (credentials_slot) {
        if (credentials_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            credentials_slot,
            credentials_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              credentials_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_credentials_slot_changes
            ),
            get_credentials_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(credentials_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(credentials_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (credentials_slot) credentials_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: '(31:2) {#if provider === \\"credentials\\"}',
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let current;
  const email_slot_template = (
    /*#slots*/
    ctx[10].email
  );
  const email_slot = create_slot(
    email_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_email_slot_context
  );
  const email_slot_or_fallback = email_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      if (email_slot_or_fallback) email_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (email_slot_or_fallback) email_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (email_slot_or_fallback) {
        email_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (email_slot) {
        if (email_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            email_slot,
            email_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              email_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_email_slot_changes
            ),
            get_email_slot_context
          );
        }
      } else {
        if (email_slot_or_fallback && email_slot_or_fallback.p && (!current || dirty & /*provider*/
        2)) {
          email_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(email_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(email_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (email_slot_or_fallback) email_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: '(35:2) {#if provider === \\"email\\" || provider === \\"sendgrid\\" || provider === \\"resend\\"}',
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let label;
  let t0;
  let label_for_value;
  let t1;
  let input;
  const block = {
    c: function create() {
      label = element("label");
      t0 = text("Email");
      t1 = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true, for: true });
      var label_nodes = children(label);
      t0 = claim_text(label_nodes, "Email");
      label_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      input = claim_element(nodes, "INPUT", {
        id: true,
        type: true,
        name: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(label, "class", "section-header");
      attr_dev(label, "for", label_for_value = `input-email-for-${/*provider*/
      ctx[1]}-provider`);
      add_location(label, file, 36, 6, 1396);
      attr_dev(input, "id", "input-email-for-email-provider");
      attr_dev(input, "type", "email");
      attr_dev(input, "name", "email");
      attr_dev(input, "placeholder", "email@example.com");
      input.required = true;
      add_location(input, file, 42, 6, 1530);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, input, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*provider*/
      2 && label_for_value !== (label_for_value = `input-email-for-${/*provider*/
      ctx2[1]}-provider`)) {
        attr_dev(label, "for", label_for_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
        detach_dev(t1);
        detach_dev(input);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(36:23)        ",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t0;
  let t1_value = (
    /*provider*/
    ctx[1] ? ` with ${/*provider*/
    ctx[1]}` : ""
  );
  let t1;
  const block = {
    c: function create() {
      t0 = text("Signin");
      t1 = text(t1_value);
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, "Signin");
      t1 = claim_text(nodes, t1_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*provider*/
      2 && t1_value !== (t1_value = /*provider*/
      ctx2[1] ? ` with ${/*provider*/
      ctx2[1]}` : "")) set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(53:30) Signin",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let form;
  let input;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let button;
  let form_action_value;
  let form_class_value;
  let enhance_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*callbackUrl*/
    ctx[3] && create_if_block_4(ctx)
  );
  let if_block1 = (
    /*redirect*/
    ctx[4] && create_if_block_3(ctx)
  );
  let if_block2 = (
    /*authorizationParamsInputs*/
    ctx[5] && create_if_block_2(ctx)
  );
  let if_block3 = (
    /*provider*/
    ctx[1] === "credentials" && create_if_block_1(ctx)
  );
  let if_block4 = (
    /*provider*/
    (ctx[1] === "email" || /*provider*/
    ctx[1] === "sendgrid" || /*provider*/
    ctx[1] === "resend") && create_if_block(ctx)
  );
  const submitButton_slot_template = (
    /*#slots*/
    ctx[10].submitButton
  );
  const submitButton_slot = create_slot(
    submitButton_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_submitButton_slot_context
  );
  const submitButton_slot_or_fallback = submitButton_slot || fallback_block(ctx);
  let form_levels = [
    { method: "POST" },
    {
      action: form_action_value = `/${/*signInPage*/
      ctx[2]}`
    },
    {
      class: form_class_value = `signInButton ${/*className*/
      ctx[0]}`
    },
    /*$$restProps*/
    ctx[6]
  ];
  let form_data = {};
  for (let i = 0; i < form_levels.length; i += 1) {
    form_data = assign(form_data, form_levels[i]);
  }
  const block = {
    c: function create() {
      form = element("form");
      input = element("input");
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      t3 = space();
      if (if_block3) if_block3.c();
      t4 = space();
      if (if_block4) if_block4.c();
      t5 = space();
      button = element("button");
      if (submitButton_slot_or_fallback) submitButton_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { method: true, action: true, class: true });
      var form_nodes = children(form);
      input = claim_element(form_nodes, "INPUT", { type: true, name: true });
      t0 = claim_space(form_nodes);
      if (if_block0) if_block0.l(form_nodes);
      t1 = claim_space(form_nodes);
      if (if_block1) if_block1.l(form_nodes);
      t2 = claim_space(form_nodes);
      if (if_block2) if_block2.l(form_nodes);
      t3 = claim_space(form_nodes);
      if (if_block3) if_block3.l(form_nodes);
      t4 = claim_space(form_nodes);
      if (if_block4) if_block4.l(form_nodes);
      t5 = claim_space(form_nodes);
      button = claim_element(form_nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (submitButton_slot_or_fallback) submitButton_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "hidden");
      attr_dev(input, "name", "providerId");
      input.value = /*provider*/
      ctx[1];
      add_location(input, file, 18, 2, 726);
      attr_dev(button, "type", "submit");
      add_location(button, file, 51, 2, 1711);
      set_attributes(form, form_data);
      add_location(form, file, 11, 0, 601);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      append_hydration_dev(form, input);
      append_hydration_dev(form, t0);
      if (if_block0) if_block0.m(form, null);
      append_hydration_dev(form, t1);
      if (if_block1) if_block1.m(form, null);
      append_hydration_dev(form, t2);
      if (if_block2) if_block2.m(form, null);
      append_hydration_dev(form, t3);
      if (if_block3) if_block3.m(form, null);
      append_hydration_dev(form, t4);
      if (if_block4) if_block4.m(form, null);
      append_hydration_dev(form, t5);
      append_hydration_dev(form, button);
      if (submitButton_slot_or_fallback) {
        submitButton_slot_or_fallback.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(enhance_action = enhance.call(null, form));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*provider*/
      2) {
        prop_dev(
          input,
          "value",
          /*provider*/
          ctx2[1]
        );
      }
      if (
        /*callbackUrl*/
        ctx2[3]
      ) if_block0.p(ctx2, dirty);
      if (
        /*redirect*/
        ctx2[4]
      ) if_block1.p(ctx2, dirty);
      if (
        /*authorizationParamsInputs*/
        ctx2[5]
      ) if_block2.p(ctx2, dirty);
      if (
        /*provider*/
        ctx2[1] === "credentials"
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*provider*/
          2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(form, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*provider*/
        ctx2[1] === "email" || /*provider*/
        ctx2[1] === "sendgrid" || /*provider*/
        ctx2[1] === "resend"
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*provider*/
          2) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(form, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (submitButton_slot) {
        if (submitButton_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            submitButton_slot,
            submitButton_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              submitButton_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_submitButton_slot_changes
            ),
            get_submitButton_slot_context
          );
        }
      } else {
        if (submitButton_slot_or_fallback && submitButton_slot_or_fallback.p && (!current || dirty & /*provider*/
        2)) {
          submitButton_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(form, form_data = get_spread_update(form_levels, [
        { method: "POST" },
        (!current || dirty & /*signInPage*/
        4 && form_action_value !== (form_action_value = `/${/*signInPage*/
        ctx2[2]}`)) && { action: form_action_value },
        (!current || dirty & /*className*/
        1 && form_class_value !== (form_class_value = `signInButton ${/*className*/
        ctx2[0]}`)) && { class: form_class_value },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(submitButton_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(submitButton_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(form);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      if (if_block4) if_block4.d();
      if (submitButton_slot_or_fallback) submitButton_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["className", "provider", "signInPage", "options", "authorizationParams"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SignIn", slots, ["credentials", "email", "submitButton"]);
  let { className = "" } = $$props;
  let { provider = "" } = $$props;
  let { signInPage = "signin" } = $$props;
  let { options = void 0 } = $$props;
  let { authorizationParams = void 0 } = $$props;
  const callbackUrl = options instanceof FormData ? options.get("redirectTo") : options == null ? void 0 : options.redirectTo;
  const redirect = options instanceof FormData ? options.get("redirect") : options == null ? void 0 : options.redirectTo;
  const authorizationParamsInputs = authorizationParams ? typeof authorizationParams === "string" && authorizationParams ? new URLSearchParams(authorizationParams) : authorizationParams : void 0;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("className" in $$new_props) $$invalidate(0, className = $$new_props.className);
    if ("provider" in $$new_props) $$invalidate(1, provider = $$new_props.provider);
    if ("signInPage" in $$new_props) $$invalidate(2, signInPage = $$new_props.signInPage);
    if ("options" in $$new_props) $$invalidate(7, options = $$new_props.options);
    if ("authorizationParams" in $$new_props) $$invalidate(8, authorizationParams = $$new_props.authorizationParams);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    enhance,
    className,
    provider,
    signInPage,
    options,
    authorizationParams,
    callbackUrl,
    redirect,
    authorizationParamsInputs
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    if ("provider" in $$props) $$invalidate(1, provider = $$new_props.provider);
    if ("signInPage" in $$props) $$invalidate(2, signInPage = $$new_props.signInPage);
    if ("options" in $$props) $$invalidate(7, options = $$new_props.options);
    if ("authorizationParams" in $$props) $$invalidate(8, authorizationParams = $$new_props.authorizationParams);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    className,
    provider,
    signInPage,
    callbackUrl,
    redirect,
    authorizationParamsInputs,
    $$restProps,
    options,
    authorizationParams,
    $$scope,
    slots
  ];
}
var SignIn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      className: 0,
      provider: 1,
      signInPage: 2,
      options: 7,
      authorizationParams: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SignIn",
      options,
      id: create_fragment.name
    });
  }
  get className() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set className(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get provider() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set provider(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get signInPage() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set signInPage(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get authorizationParams() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set authorizationParams(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SignIn_default = SignIn;

// node_modules/@auth/sveltekit/dist/components/SignOut.svelte
import { enhance as enhance2 } from "$app/forms";
var file2 = "node_modules\\@auth\\sveltekit\\dist\\components\\SignOut.svelte";
var get_submitButton_slot_changes2 = (dirty) => ({});
var get_submitButton_slot_context2 = (ctx) => ({});
function create_if_block2(ctx) {
  var _a, _b;
  let t;
  let if_block1_anchor;
  let if_block0 = (
    /*options*/
    ((_a = ctx[1]) == null ? void 0 : _a.redirect) && create_if_block_22(ctx)
  );
  let if_block1 = (
    /*options*/
    ((_b = ctx[1]) == null ? void 0 : _b.redirectTo) && create_if_block_12(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (
        /*options*/
        (_a2 = ctx2[1]) == null ? void 0 : _a2.redirect
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_22(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*options*/
        (_b2 = ctx2[1]) == null ? void 0 : _b2.redirectTo
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(14:2) {#if options}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let input;
  let input_value_value;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, name: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "hidden");
      attr_dev(input, "name", "redirect");
      input.value = input_value_value = /*options*/
      ctx[1].redirect;
      add_location(input, file2, 15, 6, 324);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*options*/
      2 && input_value_value !== (input_value_value = /*options*/
      ctx2[1].redirect)) {
        prop_dev(input, "value", input_value_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(15:4) {#if options?.redirect}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let input;
  let input_value_value;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, name: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "hidden");
      attr_dev(input, "name", "redirectTo");
      input.value = input_value_value = /*options*/
      ctx[1].redirectTo;
      add_location(input, file2, 18, 6, 435);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*options*/
      2 && input_value_value !== (input_value_value = /*options*/
      ctx2[1].redirectTo)) {
        prop_dev(input, "value", input_value_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(18:4) {#if options?.redirectTo}",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Sign Out");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Sign Out");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(23:30) Sign Out",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let form;
  let t;
  let button;
  let form_action_value;
  let form_class_value;
  let enhance_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*options*/
    ctx[1] && create_if_block2(ctx)
  );
  const submitButton_slot_template = (
    /*#slots*/
    ctx[5].submitButton
  );
  const submitButton_slot = create_slot(
    submitButton_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_submitButton_slot_context2
  );
  const submitButton_slot_or_fallback = submitButton_slot || fallback_block2(ctx);
  let form_levels = [
    { method: "POST" },
    {
      action: form_action_value = `/${/*signOutPage*/
      ctx[2]}`
    },
    {
      class: form_class_value = `signOutButton ${/*className*/
      ctx[0]}`
    },
    /*$$restProps*/
    ctx[3]
  ];
  let form_data = {};
  for (let i = 0; i < form_levels.length; i += 1) {
    form_data = assign(form_data, form_levels[i]);
  }
  const block = {
    c: function create() {
      form = element("form");
      if (if_block) if_block.c();
      t = space();
      button = element("button");
      if (submitButton_slot_or_fallback) submitButton_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { method: true, action: true, class: true });
      var form_nodes = children(form);
      if (if_block) if_block.l(form_nodes);
      t = claim_space(form_nodes);
      button = claim_element(form_nodes, "BUTTON", { type: true });
      var button_nodes = children(button);
      if (submitButton_slot_or_fallback) submitButton_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "submit");
      add_location(button, file2, 21, 2, 524);
      set_attributes(form, form_data);
      add_location(form, file2, 6, 0, 149);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      if (if_block) if_block.m(form, null);
      append_hydration_dev(form, t);
      append_hydration_dev(form, button);
      if (submitButton_slot_or_fallback) {
        submitButton_slot_or_fallback.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(enhance_action = enhance2.call(null, form));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*options*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(form, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (submitButton_slot) {
        if (submitButton_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            submitButton_slot,
            submitButton_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              submitButton_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_submitButton_slot_changes2
            ),
            get_submitButton_slot_context2
          );
        }
      }
      set_attributes(form, form_data = get_spread_update(form_levels, [
        { method: "POST" },
        (!current || dirty & /*signOutPage*/
        4 && form_action_value !== (form_action_value = `/${/*signOutPage*/
        ctx2[2]}`)) && { action: form_action_value },
        (!current || dirty & /*className*/
        1 && form_class_value !== (form_class_value = `signOutButton ${/*className*/
        ctx2[0]}`)) && { class: form_class_value },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(submitButton_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(submitButton_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(form);
      }
      if (if_block) if_block.d();
      if (submitButton_slot_or_fallback) submitButton_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["className", "options", "signOutPage"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SignOut", slots, ["submitButton"]);
  let { className = "" } = $$props;
  let { options = void 0 } = $$props;
  let { signOutPage = "signout" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("className" in $$new_props) $$invalidate(0, className = $$new_props.className);
    if ("options" in $$new_props) $$invalidate(1, options = $$new_props.options);
    if ("signOutPage" in $$new_props) $$invalidate(2, signOutPage = $$new_props.signOutPage);
    if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ enhance: enhance2, className, options, signOutPage });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    if ("options" in $$props) $$invalidate(1, options = $$new_props.options);
    if ("signOutPage" in $$props) $$invalidate(2, signOutPage = $$new_props.signOutPage);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [className, options, signOutPage, $$restProps, $$scope, slots];
}
var SignOut = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { className: 0, options: 1, signOutPage: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SignOut",
      options,
      id: create_fragment2.name
    });
  }
  get className() {
    throw new Error("<SignOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set className(value) {
    throw new Error("<SignOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<SignOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<SignOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get signOutPage() {
    throw new Error("<SignOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set signOutPage(value) {
    throw new Error("<SignOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SignOut_default = SignOut;
export {
  SignIn_default as SignIn,
  SignOut_default as SignOut
};
//# sourceMappingURL=@auth_sveltekit_components.js.map
